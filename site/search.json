{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Get started","text":"<p>For full documentation visit zensical.org.</p>","path":["Get started"],"tags":[]},{"location":"#commands","level":2,"title":"Commands","text":"<ul> <li><code>zensical new</code> - Create a new project</li> <li><code>zensical serve</code> - Start local web server</li> <li><code>zensical build</code> - Build your site</li> </ul>","path":["Get started"],"tags":[]},{"location":"#examples","level":2,"title":"Examples","text":"","path":["Get started"],"tags":[]},{"location":"#admonitions","level":3,"title":"Admonitions","text":"<p>Go to documentation</p> <p>Note</p> <p>This is a note admonition. Use it to provide helpful information.</p> <p>Warning</p> <p>This is a warning admonition. Be careful!</p>","path":["Get started"],"tags":[]},{"location":"#details","level":3,"title":"Details","text":"<p>Go to documentation</p> Click to expand for more info <p>This content is hidden until you click to expand it. Great for FAQs or long explanations.</p>","path":["Get started"],"tags":[]},{"location":"#code-blocks","level":2,"title":"Code Blocks","text":"<p>Go to documentation</p> Code blocks<pre><code>def greet(name):\n    print(f\"Hello, {name}!\") # (1)!\n\ngreet(\"Python\")\n</code></pre> <ol> <li> <p>Go to documentation</p> <p>Code annotations allow to attach notes to lines of code.</p> </li> </ol> <p>Code can also be highlighted inline: <code>print(\"Hello, Python!\")</code>.</p>","path":["Get started"],"tags":[]},{"location":"#content-tabs","level":2,"title":"Content tabs","text":"<p>Go to documentation</p> PythonRust <pre><code>print(\"Hello from Python!\")\n</code></pre> <pre><code>println!(\"Hello from Rust!\");\n</code></pre>","path":["Get started"],"tags":[]},{"location":"#diagrams","level":2,"title":"Diagrams","text":"<p>Go to documentation</p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>","path":["Get started"],"tags":[]},{"location":"#footnotes","level":2,"title":"Footnotes","text":"<p>Go to documentation</p> <p>Here's a sentence with a footnote.<sup>1</sup></p> <p>Hover it, to see a tooltip.</p>","path":["Get started"],"tags":[]},{"location":"#formatting","level":2,"title":"Formatting","text":"<p>Go to documentation</p> <ul> <li>This was marked (highlight)</li> <li>This was inserted (underline)</li> <li>This was deleted (strikethrough)</li> <li>H<sub>2</sub>O</li> <li>A<sup>T</sup>A</li> <li>Ctrl+Alt+Del</li> </ul>","path":["Get started"],"tags":[]},{"location":"#icons-emojis","level":2,"title":"Icons, Emojis","text":"<p>Go to documentation</p> <ul> <li> <code>:sparkles:</code></li> <li> <code>:rocket:</code></li> <li> <code>:tada:</code></li> <li> <code>:memo:</code></li> <li> <code>:eyes:</code></li> </ul>","path":["Get started"],"tags":[]},{"location":"#maths","level":2,"title":"Maths","text":"<p>Go to documentation</p> \\[ \\cos x=\\sum_{k=0}^{\\infty}\\frac{(-1)^k}{(2k)!}x^{2k} \\] <p>Needs configuration</p> <p>Note that MathJax is included via a <code>script</code> tag on this page and is not configured in the generated default configuration to avoid including it in a pages that do not need it. See the documentation for details on how to configure it on all your pages if they are more Maths-heavy than these simple starter pages.</p>","path":["Get started"],"tags":[]},{"location":"#task-lists","level":2,"title":"Task Lists","text":"<p>Go to documentation</p> <ul> <li> Install Zensical</li> <li> Configure <code>zensical.toml</code></li> <li> Write amazing documentation</li> <li> Deploy anywhere</li> </ul>","path":["Get started"],"tags":[]},{"location":"#tooltips","level":2,"title":"Tooltips","text":"<p>Go to documentation</p> <p>Hover me</p> <ol> <li> <p>This is the footnote. ↩</p> </li> </ol>","path":["Get started"],"tags":[]},{"location":"devops/introduction/why-devops/","level":1,"title":"Why DevOps?","text":"","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#a-simple-starting-point","level":2,"title":"A simple starting point","text":"<p>A developer writes some code.</p> <p>The code works on the developer’s laptop. Now it needs to run on a server so users can use it.</p> <p>This step moving code from a laptop to a server is where problems usually start.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#what-was-the-problem","level":2,"title":"What was the problem?","text":"<p>Earlier, deployments followed a documented checklist.</p> <p>A typical checklist looked like this:</p> <ol> <li>Download the build  </li> <li>Unzip it  </li> <li>Copy files to the application directory  </li> <li>Ensure correct file ownership and permissions  </li> <li>Restart the application  </li> </ol> <p>The issue was not lack of documentation.</p> <p>The issue was how the same steps were executed.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#a-realistic-example-of-variation","level":2,"title":"A realistic example of variation","text":"<p>Consider this checklist step:</p> <p>“Ensure correct file ownership and permissions”</p> <p>The document also stated: - Files should be owned by <code>appuser</code> - Permissions should match the existing release</p> <p>Now two engineers follow this.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#engineer-a","level":3,"title":"Engineer A","text":"<ul> <li>Copies the new files over the existing directory</li> <li>Old files that no longer exist in the new build are left behind</li> <li>Existing ownership and permissions are preserved</li> </ul>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#engineer-b","level":3,"title":"Engineer B","text":"<ul> <li>Removes the old directory completely</li> <li>Copies the new files into a clean directory</li> <li>Applies ownership and permissions explicitly</li> </ul> <p>Both approaches are reasonable. Both follow the document.</p> <p>But the result is different.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#why-was-this-risky","level":2,"title":"Why was this risky?","text":"<p>Because copying over an old directory can:</p> <ul> <li>Leave obsolete files on disk  </li> <li>Preserve permissions from a previous release  </li> <li>Apply unintended configuration  </li> <li>Make behavior depend on what was deployed earlier  </li> </ul> <p>The application may start successfully and still behave incorrectly later.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#the-simple-idea-behind-devops","level":2,"title":"The simple idea behind DevOps","text":"<p>A small but important change:</p> <p>“Every deployment must create the same directory structure, with the same files, ownership, and permissions — regardless of what existed before.”</p> <p>So instead of: - Adjusting things based on the previous deployment</p> <p>We move to: - Recreating the application directory in a known way - Applying ownership and permissions explicitly - Making each deployment independent of history</p> <p>This approach is called DevOps.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#what-changed-after-this","level":2,"title":"What changed after this?","text":"<ul> <li>Deployments behaved the same way every time  </li> <li>Permission issues stopped appearing unexpectedly  </li> <li>Old files stopped affecting new releases  </li> <li>Failures became easier to explain and reproduce  </li> </ul> <p>Nothing became fancy. Things became predictable.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/introduction/why-devops/#one-takeaway","level":2,"title":"One takeaway","text":"<p>DevOps exists because relying on previous server state is risky.</p> <p>DevOps removes that risk by recreating the application exactly as intended on every deployment.</p>","path":["Devops","Introduction","Why DevOps?"],"tags":["devops"]},{"location":"devops/linux/linux-commands/","level":1,"title":"Introduction to Linux (How to Think)","text":"<p>This document introduces Linux by explaining how to reason about a Linux system, not just which commands exist. The goal is to help understand why Linux behaves the way it does, so later topics (DevOps, containers, automation) feel natural.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#how-linux-is-different-from-windows-the-core-idea","level":2,"title":"How Linux is different from Windows (the core idea)","text":"<p>Linux and Windows solve different problems.</p> <p>Windows was designed for individual desktop users:</p> <ul> <li>Strong focus on GUI</li> <li>System internals are intentionally hidden</li> <li>Manual interaction is the default</li> </ul> <p>Linux was designed for multi-user systems and servers:</p> <ul> <li>System internals are visible</li> <li>Everything is controlled using files and processes</li> <li>Automation is expected, not optional</li> </ul> <p>A useful mental model:</p> <ul> <li>Windows is like ready-made furniture: polished and convenient, but hard to modify internally.</li> <li>Linux is like Lego bricks in a workshop: smaller pieces, fully visible, and easy to assemble differently.</li> </ul> <p>This single difference explains why Linux dominates servers and DevOps.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#why-linux-became-the-base-for-devops-and-cloud","level":2,"title":"Why Linux became the base for DevOps and cloud","text":"<p>Linux exposes low-level system behavior in a way automation tools can directly control.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#containers-why-linux-is-required","level":3,"title":"Containers (why Linux is required)","text":"<p>Containers are not a generic technology; they depend on Linux kernel features:</p> <ul> <li>Namespaces isolate processes, networks, and filesystems.</li> <li>cgroups control CPU and memory usage.</li> <li>chroot limits filesystem visibility.</li> </ul> <p>Because of this:</p> <ul> <li>A container is a restricted Linux process.</li> <li>It is not a virtual machine.</li> <li>On Windows or macOS, Docker runs a small Linux VM in the background.</li> <li>Containers still execute on a Linux kernel.</li> </ul> <p>This is a technical dependency, not a preference.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#configuration-management-ansible","level":3,"title":"Configuration management (Ansible)","text":"<p>Ansible assumes Linux-style systems:</p> <ul> <li>SSH-based remote execution</li> <li>Text configuration files</li> <li>Linux users, permissions, and package managers</li> </ul> <p>Windows support exists, but:</p> <ul> <li>Requires WinRM</li> <li>Uses separate modules</li> <li>Adds complexity</li> </ul> <p>Linux aligns naturally with automation, so it remains the default.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#what-linux-actually-means-distributions","level":2,"title":"What “Linux” actually means (distributions)","text":"<p>Linux itself is only the kernel. A usable system is created by combining the kernel with tools, libraries, and defaults. This is called a distribution.</p> <p>Example:</p> <ul> <li>RHEL = enterprise Linux with paid support</li> <li>CentOS = community rebuild of RHEL (same structure, no support)</li> </ul> <p>Different distributions exist, but the core concepts do not change.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#how-you-interact-with-linux-cli-first-thinking","level":2,"title":"How you interact with Linux (CLI-first thinking)","text":"<p>Linux provides both GUI and CLI, but servers are CLI-only.</p> <p>This matters because:</p> <ul> <li>Scripts run CLI commands</li> <li>Automation uses CLI commands</li> <li>Troubleshooting happens via CLI</li> </ul> <p>Learning Linux means learning to reason through commands.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#shells-how-linux-interprets-commands","level":2,"title":"Shells: how Linux interprets commands","text":"<p>A shell is the program that reads your command and decides what to execute.</p> <p>Common shells:</p> <ul> <li><code>sh</code> – original Bourne shell</li> <li><code>csh</code> / <code>tcsh</code> – C-style syntax</li> <li><code>zsh</code> – modern interactive shell</li> <li><code>bash</code> – default on most enterprise systems</li> </ul> <p><code>bash</code> is important because it supports:</p> <ul> <li>Variables</li> <li>Arithmetic</li> <li>Conditions</li> <li>Loops</li> <li>Scripts</li> </ul> <p>Check which shell you are using:</p> <pre><code>echo $SHELL\n</code></pre> <p>Interpretation:</p> <ul> <li><code>/bin/bash</code> means Bash is processing your commands</li> <li>Scripts will behave according to Bash rules</li> </ul>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#understanding-the-operating-system-thinking-not-guessing","level":2,"title":"Understanding the operating system (thinking, not guessing)","text":"<p>Before running commands or installing software, you must know what OS you are on. Different OS versions mean different package managers, paths, and defaults.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#method-1-distribution-identity-most-common","level":3,"title":"Method 1: Distribution identity (most common)","text":"<pre><code>cat /etc/os-release\n</code></pre> <p>This tells you:</p> <ul> <li>Distribution name</li> <li>Version</li> <li>Vendor</li> </ul> <p>Use this when deciding:</p> <ul> <li>Which package manager to use</li> <li>Which documentation applies</li> </ul>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#method-2-compatibility-check-practical-admin-view","level":3,"title":"Method 2: Compatibility check (practical admin view)","text":"<pre><code>ls /etc/*release*\n</code></pre> <p>Why this exists:</p> <ul> <li>Many tools and scripts only check for file presence</li> <li>Legacy systems may not have <code>os-release</code></li> </ul> <p>This helps you reason about backward compatibility.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#method-3-kernel-vs-os-distinction-advanced-thinking","level":3,"title":"Method 3: Kernel vs OS distinction (advanced thinking)","text":"<pre><code>uname -a\n</code></pre> <p>This tells you:</p> <ul> <li>Kernel version</li> <li>Architecture</li> </ul> <p>Important insight:</p> <ul> <li>Two systems can run the same kernel</li> <li>But behave differently due to distribution-level tools</li> </ul> <p>Kernel ≠ distribution.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#core-linux-commands-mental-model-first","level":2,"title":"Core Linux commands (mental model first)","text":"<p>Linux commands are intentionally small and focused.</p> <p>Examples:</p> <pre><code>echo Hi        # print output\nls             # list files\ncd /path       # move in filesystem\npwd            # show current location\nmkdir test     # create directory\n</code></pre> <p>Key idea:</p> <ul> <li>Commands do one thing</li> <li>You combine them to do complex tasks</li> </ul>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#files-and-directories","level":3,"title":"Files and directories","text":"<p>Create nested paths:</p> <pre><code>mkdir -p /tmp/asia/india/bangalore\n</code></pre> <p>Remove recursively:</p> <pre><code>rm -r old_dir\n</code></pre> <p>Copy directories:</p> <pre><code>cp -r src dest\n</code></pre> <p>Create files:</p> <pre><code>touch file.txt\n</code></pre> <p>Write content:</p> <pre><code>cat &gt; file.txt\n</code></pre> <p>Read content:</p> <pre><code>cat file.txt\n</code></pre> <p>Linux treats everything as files, including configuration and devices.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#editing-files-with-vi-why-it-still-exists","level":2,"title":"Editing files with vi (why it still exists)","text":"<p><code>vi</code> is always available, even on minimal servers.</p> <p>Understanding vi is about survivability, not preference.</p> <p>Basic flow:</p> <ul> <li>Open file → command mode</li> <li>Press <code>i</code> → insert mode</li> <li>Press <code>Esc</code> → command mode</li> </ul> <p>Common actions:</p> <ul> <li>Save: <code>:w</code></li> <li>Quit: <code>:q</code></li> <li>Save and quit: <code>:wq</code></li> <li>Search: <code>/word</code></li> </ul> <p>You do not need speed. You need reliability.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#users-and-permissions-how-linux-thinks-about-access","level":2,"title":"Users and permissions (how Linux thinks about access)","text":"<p>Linux separates identity from privilege.</p> <p>Check identity:</p> <pre><code>whoami\nid\n</code></pre> <p>Switch users:</p> <pre><code>su\n</code></pre> <p>Remote login:</p> <pre><code>ssh user@host\n</code></pre> <p><code>root</code> is the superuser. Regular users are restricted by default.</p> <p>Example:</p> <pre><code>ls /root\n</code></pre> <p>Result:</p> <pre><code>Permission denied\n</code></pre> <p>With controlled privilege:</p> <pre><code>sudo ls /root\n</code></pre> <p>Sudo:</p> <ul> <li>Temporarily elevates privilege</li> <li>Requires user authentication</li> <li>Logs every action</li> </ul>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#downloading-files-automation-friendly","level":2,"title":"Downloading files (automation-friendly)","text":"<p>Using curl:</p> <pre><code>curl &lt;url&gt; -O\n</code></pre> <p>Using wget:</p> <pre><code>wget &lt;url&gt; -O file_name\n</code></pre> <p>Both are commonly used in scripts and pipelines.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#installing-software-how-linux-decides-dependencies","level":2,"title":"Installing software (how Linux decides dependencies)","text":"","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#rpm-low-level","level":3,"title":"rpm (low-level)","text":"<pre><code>rpm -i ansible.rpm\n</code></pre> <ul> <li>Installs one package</li> <li>Does not resolve dependencies</li> </ul> <p>Use when:</p> <ul> <li>Offline installs</li> <li>Controlled environments</li> </ul>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#yum-high-level","level":3,"title":"yum (high-level)","text":"<pre><code>yum install ansible\n</code></pre> <ul> <li>Resolves dependencies</li> <li>Uses repositories</li> </ul> <p>Repositories live in:</p> <pre><code>/etc/yum.repos.d/\n</code></pre> <p>Yum:</p> <ul> <li>Compares available versions</li> <li>Selects compatible packages</li> <li>Avoids conflicts</li> </ul> <p>Other systems use:</p> <ul> <li><code>apt</code></li> <li><code>dnf</code></li> <li><code>zypper</code></li> </ul> <p>The idea is the same everywhere.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#services-and-systemd-process-thinking","level":2,"title":"Services and systemd (process thinking)","text":"<p>Modern Linux uses systemd to manage services.</p> <p>Check service state:</p> <pre><code>systemctl status my_app\n</code></pre> <p>Start service:</p> <pre><code>systemctl start my_app\n</code></pre> <p>Older <code>service</code> command still exists but wraps <code>systemctl</code>.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-commands/#creating-a-simple-service-reasoning-example","level":2,"title":"Creating a simple service (reasoning example)","text":"<p>You have:</p> <pre><code>/opt/my_app/my_app.py\n</code></pre> <p>Create:</p> <pre><code>/etc/systemd/system/my_app.service\n</code></pre> <pre><code>[Unit]\nDescription=My Sample App\n\n[Service]\nExecStart=/usr/bin/python3 /opt/my_app/my_app.py\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Reload systemd:</p> <pre><code>systemctl daemon-reload\n</code></pre> <p>Enable and start:</p> <p><pre><code>systemctl enable my_app\nsystemctl start my_app\n</code></pre> Thinking model:</p> <ul> <li><code>[Unit]</code> explains what</li> <li><code>[Service]</code> explains how</li> <li><code>[Install]</code> explains when</li> </ul> <p>Linux is powerful because it exposes its internals in a consistent, scriptable way. Once you understand how Linux thinks about identity, files, processes, and services, DevOps and cloud concepts stop feeling magical and start feeling logical.</p>","path":["Devops","Linux","Functional use cases"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/","level":1,"title":"Linux Filesystem Layout","text":"","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#how-john-learns-why-everything-lives-where-it-does","level":2,"title":"How John Learns Why Everything Lives Where It Does","text":"<p>John is now comfortable logging into Linux. He can run commands, edit files, and start services. But one question keeps coming up:</p> <p>“Where should things actually go?”</p> <p>Linux does not place files randomly. The filesystem layout exists to solve real operational problems.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#john-explores-the-root-of-the-filesystem","level":2,"title":"John explores the root of the filesystem","text":"<p>John starts at the top:</p> <pre><code>ls /\n</code></pre> <p>He sees directories like <code>/bin</code>, <code>/etc</code>, <code>/var</code>, <code>/opt</code>, <code>/home</code>, <code>/tmp</code>.</p> <p>At first, this looks arbitrary. It is not.</p> <p>Linux follows a standard layout so that:</p> <ul> <li>admins know where to look</li> <li>tools know where to read from</li> <li>automation behaves consistently across systems</li> </ul>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#home-where-humans-live","level":2,"title":"<code>/home</code>: where humans live","text":"<p>John checks:</p> <pre><code>ls /home\n</code></pre> <p>He sees his own directory:</p> <pre><code>/home/john\n</code></pre> <p>This directory exists because:</p> <ul> <li>each user needs a private workspace</li> <li>permissions isolate users from each other</li> <li>backups can target user data easily</li> </ul> <p>John creates a file:</p> <pre><code>touch /home/john/test.txt\n</code></pre> <p>Linux allows this because John owns his home directory.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#root-why-john-was-denied-earlier","level":2,"title":"<code>/root</code>: why John was denied earlier","text":"<p>Earlier, John tried:</p> <pre><code>ls /root\n</code></pre> <p>and got “permission denied”.</p> <p>Now it makes sense.</p> <p><code>/root</code> is:</p> <ul> <li>the home directory of the <code>root</code> user</li> <li>intentionally separate from <code>/home</code></li> <li>protected from regular users</li> </ul> <p>Root is a user, not magic. It just has a different home.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#bin-and-sbin-basic-commands-live-here","level":2,"title":"<code>/bin</code> and <code>/sbin</code>: basic commands live here","text":"<p>John wonders where commands like <code>ls</code> actually come from.</p> <p>He checks:</p> <pre><code>which ls\n</code></pre> <p>Output:</p> <pre><code>/bin/ls\n</code></pre> <p>This tells him:</p> <ul> <li><code>/bin</code> contains essential user commands</li> <li>these commands must be available even in recovery mode</li> </ul> <p>Similarly:</p> <pre><code>which ip\n</code></pre> <p>might point to:</p> <pre><code>/sbin/ip\n</code></pre> <p><code>/sbin</code> contains system-level commands meant for administrators.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#etc-configuration-lives-here-and-only-here","level":2,"title":"<code>/etc</code>: configuration lives here (and only here)","text":"<p>John edits a service file earlier in <code>/etc/systemd/system</code>. Now he understands why.</p> <p><code>/etc</code> exists for configuration only.</p> <p>John lists it:</p> <pre><code>ls /etc\n</code></pre> <p>He sees:</p> <ul> <li>service configs</li> <li>user configs</li> <li>network configs</li> </ul> <p>Important rule:</p> <p>Executables do not live in <code>/etc</code>. Data does not live in <code>/etc</code>. Only configuration.</p> <p>This separation allows:</p> <ul> <li>safe upgrades</li> <li>easy backups</li> <li>predictable automation</li> </ul>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#var-data-that-changes-while-the-system-runs","level":2,"title":"<code>/var</code>: data that changes while the system runs","text":"<p>John notices logs are not in <code>/etc</code>.</p> <p>He checks:</p> <pre><code>ls /var\n</code></pre> <p>He sees directories like:</p> <ul> <li><code>/var/log</code></li> <li><code>/var/lib</code></li> <li><code>/var/tmp</code></li> </ul> <p>He opens logs:</p> <pre><code>ls /var/log\n</code></pre> <p>This explains why:</p> <ul> <li>logs grow over time</li> <li>disk-full issues often come from <code>/var</code></li> <li><code>/var</code> is monitored closely in production</li> </ul> <p>Applications write changing data here, not in <code>/etc</code>.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#tmp-temporary-means-temporary","level":2,"title":"<code>/tmp</code>: temporary means temporary","text":"<p>John creates a file:</p> <pre><code>touch /tmp/test.tmp\n</code></pre> <p>It works. But after a reboot, the file is gone.</p> <p>This teaches an important rule:</p> <p><code>/tmp</code> is for short-lived files only.</p> <p>System cleanups and reboots can wipe it at any time.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#opt-where-applications-belong","level":2,"title":"<code>/opt</code>: where applications belong","text":"<p>John earlier placed his app in <code>/opt/my_app</code>.</p> <p>Now he understands why.</p> <p><code>/opt</code> exists for:</p> <ul> <li>optional software</li> <li>third-party applications</li> <li>custom deployments</li> </ul> <p>This keeps applications separate from:</p> <ul> <li>OS binaries (<code>/bin</code>)</li> <li>configs (<code>/etc</code>)</li> <li>logs (<code>/var/log</code>)</li> </ul> <p>In production systems, this separation prevents accidental overwrites during OS upgrades.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#usr-os-installed-software","level":2,"title":"<code>/usr</code>: OS-installed software","text":"<p>John installs a package:</p> <pre><code>yum install python3\n</code></pre> <p>He checks:</p> <pre><code>which python3\n</code></pre> <p>Output:</p> <pre><code>/usr/bin/python3\n</code></pre> <p>This tells him:</p> <ul> <li><code>/usr</code> holds OS-managed software</li> <li>package managers control this space</li> <li>admins should not manually edit files here</li> </ul>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#why-this-layout-matters-in-real-systems","level":2,"title":"Why this layout matters in real systems","text":"<p>Later, John joins a production incident call.</p> <p>The service is down.</p> <p>The team asks:</p> <ul> <li>“Check logs” → <code>/var/log</code></li> <li>“Check config” → <code>/etc</code></li> <li>“Check app binaries” → <code>/opt</code></li> <li>“Check user scripts” → <code>/home</code></li> </ul> <p>No guessing. Everyone knows where to look.</p> <p>That is the real value of the filesystem layout.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#johns-final-mental-model","level":2,"title":"John’s final mental model","text":"<p>John now thinks about Linux like this:</p> <ul> <li><code>/home</code> → humans</li> <li><code>/root</code> → superuser</li> <li><code>/bin</code>, <code>/sbin</code> → core commands</li> <li><code>/etc</code> → configuration</li> <li><code>/var</code> → changing data</li> <li><code>/opt</code> → applications</li> <li><code>/tmp</code> → temporary files</li> <li><code>/usr</code> → OS-managed software</li> </ul> <p>Linux did not choose this structure randomly. It chose it so humans and automation could work together without confusion.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-filesystem/#final-takeaway","level":2,"title":"Final takeaway","text":"<p>Understanding the Linux filesystem is not about memorizing directories. It is about knowing where responsibility lives.</p> <p>Once John understands this, production systems stop feeling chaotic and start feeling organized.</p>","path":["Devops","Linux","Linux File system"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/","level":1,"title":"Processes, Signals, and Ports","text":"","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#how-linux-actually-runs-things","level":2,"title":"How Linux Actually Runs Things","text":"<p>If you want to understand Linux beyond commands, you must understand three ideas: processes, signals, and ports. These are not advanced topics. They are the core mechanics of how Linux runs anything at all.</p> <p>Once these are clear, many things that look confusing—hung services, failed restarts, port conflicts, Kubernetes behaviour—start making sense.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#what-linux-means-by-a-process","level":2,"title":"What Linux means by a “process”","text":"<p>In Linux, a process is simply a running program.</p> <p>When you type a command like:</p> <pre><code>ls\n</code></pre> <p>Linux does not “run ls” in a magical way. The kernel performs a very specific sequence of actions. It creates a new process, assigns it a unique number called a PID, runs the program in memory, and destroys the process once the work is done.</p> <p>This same model applies everywhere. A shell command, a Python script, a database, a web server, or a container—all of them are processes from Linux’s point of view. Linux does not care what the program does; it only manages how it runs.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#observing-processes-instead-of-guessing","level":2,"title":"Observing processes instead of guessing","text":"<p>To understand what is happening on a system, you do not guess. You observe processes.</p> <p>A command like:</p> <pre><code>ps -ef\n</code></pre> <p>shows you what is running at that moment. It tells you which user started a process, which process started it, and what command was used. This matters because Linux always knows who started what, and responsibility is never ambiguous.</p> <p>For live systems, administrators usually use:</p> <pre><code>top\n</code></pre> <p>This answers practical questions like why a server feels slow or which process is consuming memory. Performance troubleshooting in Linux almost always begins by looking at processes, not logs.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#parent-and-child-processes-why-structure-matters","level":2,"title":"Parent and child processes (why structure matters)","text":"<p>Processes in Linux are not random. They form a tree.</p> <p>When one process starts another, the first becomes the parent and the second becomes the child. For example, a shell may start a Python process, which in turn starts another helper process. Linux keeps track of this entire relationship.</p> <p>This structure explains many behaviours. If a parent process dies, child processes may also stop, or they may be adopted by another process. This is why long-running applications should not be started casually in the background.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#pid-1-and-why-systemd-exists","level":2,"title":"PID 1 and why systemd exists","text":"<p>Every Linux system has a special process with PID 1. This is the first process started by the kernel, and on modern systems it is <code>systemd</code>.</p> <p>The role of PID 1 is not to run applications directly. Its role is to manage other processes. It starts services, restarts them if they crash, handles shutdown, and cleans up orphaned processes. Without PID 1 doing this work, Linux would slowly become unstable.</p> <p>This is why systemd is not optional on modern servers. It exists to keep the process tree healthy.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#foreground-and-background-processes","level":2,"title":"Foreground and background processes","text":"<p>When you run a command normally, it runs in the foreground. Your terminal stays attached to the process, and you cannot do anything else until it exits.</p> <p>When you append <code>&amp;</code>, the process runs in the background, detached from your terminal. However, this does not mean the process is managed. It simply means your shell is no longer waiting for it.</p> <p>This distinction matters because production services should never depend on terminals. They should be managed by systemd, not by background execution.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#signals-how-linux-talks-to-processes","level":2,"title":"Signals: how Linux talks to processes","text":"<p>Linux does not control processes by force. It communicates with them using signals.</p> <p>A signal is a message sent by the kernel to a process. The message tells the process what is happening or what is expected of it. For example, when you press Ctrl+C, Linux sends a signal asking the process to stop.</p> <p>When you run:</p> <pre><code>kill &lt;PID&gt;\n</code></pre> <p>Linux sends a polite signal requesting the process to terminate. Well-written applications respond by cleaning up and exiting gracefully. If a process ignores this request, a stronger signal can be sent that forces it to stop immediately.</p> <p>The important idea here is not memorizing signal numbers. The important idea is understanding that Linux asks first, and forces only as a last resort.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#why-signals-matter-in-real-systems","level":2,"title":"Why signals matter in real systems","text":"<p>In production systems, signals separate good applications from bad ones.</p> <p>A good application listens for termination signals, closes files, releases ports, and exits cleanly. A poorly written application ignores signals, leaves resources behind, and causes unpredictable behaviour. Many “mysterious” production issues are simply applications mishandling signals.</p> <p>This is also why platforms like Kubernetes rely heavily on signals during pod shutdown.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#ports-how-processes-expose-services","level":2,"title":"Ports: how processes expose services","text":"<p>A port is not a process. A port is simply a number managed by the kernel.</p> <p>When a server application starts, it asks the kernel to associate itself with a port. If the kernel grants the request, traffic arriving on that port is forwarded to the process. If another process already owns the port, the request fails.</p> <p>This explains why errors like “address already in use” occur. Linux is preventing two processes from listening on the same port at the same time.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#understanding-port-ownership","level":2,"title":"Understanding port ownership","text":"<p>To troubleshoot network issues, you must connect ports back to processes.</p> <p>A command like:</p> <pre><code>ss -lntp\n</code></pre> <p>shows which processes are listening on which ports. This allows you to answer concrete questions: which application is using port 8080, why a service failed to start, or whether an old process is still running.</p> <p>Ports never exist on their own. They always belong to processes.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#how-systemd-signals-and-ports-work-together","level":2,"title":"How systemd, signals, and ports work together","text":"<p>When you stop a service using systemd, Linux follows a controlled sequence. Systemd sends a termination signal, waits for the process to exit cleanly, and only forces termination if the process refuses to stop. When the process exits, its ports are automatically released.</p> <p>This predictable behaviour is the reason modern Linux systems remain stable even under frequent restarts and deployments.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#final-way-to-think-about-it","level":2,"title":"Final way to think about it","text":"<p>Linux runs programs as processes. It communicates with them using signals. Processes expose functionality to the network using ports.</p> <p>Nothing more, nothing less.</p> <p>If you understand this model, Linux stops feeling opaque and starts feeling logical.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#final-takeaway","level":2,"title":"Final takeaway","text":"<p>Linux does not hide how things run. It exposes processes, signals, and ports so that you can reason about system behaviour instead of guessing. This transparency is the reason Linux scales so well in servers, containers, and cloud platforms.</p> <p>This version should now feel connected, readable, and intentional, not like copied documentation.</p>","path":["Devops","Linux","Process, Signals and Ports"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/","level":1,"title":"How Linux Server Access Is Set Up in Enterprises","text":"<p>When an enterprise sets up its first Linux server, access control usually starts in the simplest possible way. The server runs Red Hat Enterprise Linux, the <code>root</code> user exists, and an administrator logs in directly to perform all tasks. At this stage, nothing feels wrong because only one person is using the system.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#john-joins-the-company","level":2,"title":"John joins the company","text":"<p>John joins the company as an application developer. To work on his application, he needs access to the Linux server. John raises an access request using the company’s access management tool, such as SailPoint, Saviynt, or an in-house system.</p> <p>The Linux administrator creates a local user account for John and sets a password.</p> <pre><code>useradd -m john\npasswd john\n</code></pre> <p>This updates the standard Linux account files: <code>/etc/passwd</code> stores the user entry, <code>/etc/shadow</code> stores the password hash, and <code>/etc/group</code> records group membership. John is given the server address, a username, and a temporary password. He can now log in using SSH.</p> <pre><code>ssh john@server\n</code></pre> <p>John can access his home directory, but he cannot read system directories such as <code>/root</code>. This is expected and correct.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#the-first-mistake-giving-everyone-sudo","level":2,"title":"The first mistake: giving everyone sudo","text":"<p>Very soon, John needs to start the application, run scripts, and check logs. The quickest solution seems to be adding John to sudo.</p> <pre><code>usermod -aG wheel john\n</code></pre> <p>Now John can become root using <code>sudo</code>. This works, but it introduces a serious problem. John is no longer just an application developer; he now has full control of the operating system. When a second developer joins, the same access is given again. At this point, multiple developers can act as root, and the server becomes fragile and unsafe.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#introducing-an-application-service-account","level":2,"title":"Introducing an application service account","text":"<p>The first real application is deployed, and a new question appears: who should own the application and run it? The answer is neither a human user nor root. Applications should run under their own service accounts.</p> <p>The administrator creates a dedicated application user.</p> <pre><code>useradd -r -m -d /opt/app -s /sbin/nologin appsvc\npasswd -l appsvc\n</code></pre> <p>This account exists only to run the application. No one logs in as this user. Application files and logs are owned by <code>appsvc</code>, which cleanly separates application activity from human activity.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#giving-developers-the-right-access","level":2,"title":"Giving developers the right access","text":"<p>Developers like John need to manage the application, but they do not need root access. This is solved by using groups and sudo rules instead of direct privileges.</p> <p>A group is created for application administrators, and developers are added to it.</p> <pre><code>groupadd app-admin\nusermod -aG app-admin john\n</code></pre> <p>A sudo rule is then defined.</p> <p>File: <code>/etc/sudoers.d/app-admin</code></p> <pre><code>%app-admin ALL=(appsvc) ALL\n</code></pre> <p>Now John can run application commands as the application user without becoming root.</p> <pre><code>sudo -u appsvc ./start.sh\n</code></pre> <p>The boundary is clear: developers manage the application, and the operating system remains protected.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#production-servers-and-operations-access","level":2,"title":"Production servers and operations access","text":"<p>When a production server is introduced, an operations team is responsible for system stability. These users need higher privileges than developers, but they still should not log in as root.</p> <p>An operations group is created, and sudo access is granted through that group.</p> <pre><code>groupadd linux-admin\nusermod -aG linux-admin ops1\n</code></pre> <p>File: <code>/etc/sudoers.d/linux-admin</code></p> <pre><code>%linux-admin ALL=(ALL) ALL\n</code></pre> <p>At the same time, direct root login is disabled in <code>/etc/ssh/sshd_config</code>. Root exists, but it is accessed only through sudo, ensuring every action is logged.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#scaling-the-model","level":2,"title":"Scaling the model","text":"<p>As the company grows, manually creating users on every server becomes unmanageable. At this point, the enterprise integrates Linux servers with a central directory such as LDAP or Active Directory and connects it to an IGA tool.</p> <p>Linux no longer manages users directly. It trusts directory users and groups, configured through files like <code>/etc/sssd/sssd.conf</code> and <code>/etc/nsswitch.conf</code>. Access is now granted by adding a user to the correct group in the directory, and the change applies consistently across all servers.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#final-state","level":2,"title":"Final state","text":"<p>In the final, stable setup, people log in using personal accounts, applications run as service users, and root access is available only through sudo. Groups define what users can do, and all access is auditable through logs such as <code>/var/log/secure</code> and <code>journalctl</code>.</p> <p>This structure exists because enterprises had to move from “just give root” to a model that scales safely, supports audits, and clearly separates human access from application execution.</p>","path":["Devops","Linux","User Management in Linux Servers"],"tags":["devops"]},{"location":"devops/networking/dns/","level":1,"title":"DNS Basics","text":"","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#how-names-become-ip-addresses","level":2,"title":"How names become IP addresses","text":"<p>John now has machines talking to each other across networks. Networking works.</p> <p>But there is still a problem.</p> <p>Communicating using IP addresses is painful. IPs are hard to remember and do not explain what a machine actually does.</p> <p>This is where DNS comes in.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#the-problem-why-dns-exists","level":2,"title":"The problem (why DNS exists)","text":"<p>John has a database server with this IP:</p> <pre><code>192.168.1.1\n</code></pre> <p>He can reach it, but:</p> <ul> <li>The IP does not say what the machine is</li> <li>Humans do not remember IPs easily</li> <li>IPs can change</li> </ul> <p>John wants to say:</p> <p>“Connect to the database server”</p> <p>not:</p> <p>“Connect to 192.168.1.1”</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#name-resolution-the-basic-idea","level":2,"title":"Name resolution (the basic idea)","text":"<p>Name resolution means:</p> <p>Converting a name into an IP address</p> <p>Example: <pre><code>db  →  192.168.1.1\n\n````\n\nLinux always performs name resolution before connecting to a host.\n\n---\n\n## `/etc/hosts` (local name resolution)\n\nJohn starts with the simplest method.\n\nHe edits:\n\n```bash\n/etc/hosts\n````\n\nAdds:\n\n```text\n192.168.1.1 db\n</code></pre></p> <p>Now he runs:</p> <pre><code>ping db\n</code></pre> <p>It works.</p> <p>Linux replaced <code>db</code> with <code>192.168.1.1</code>.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#why-etchosts-does-not-scale","level":2,"title":"Why <code>/etc/hosts</code> does not scale","text":"<p><code>/etc/hosts</code> works, but it has serious limitations.</p> <ul> <li>It is local to one system</li> <li>Another system may use a different name for the same IP</li> <li>IP changes require updating every machine</li> <li>Wrong entries can silently break communication</li> </ul> <p>This approach works only for:</p> <ul> <li>Very small setups</li> <li>Temporary test systems</li> </ul> <p>For large environments, this does not scale.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#dns-server-central-source-of-truth","level":2,"title":"DNS server (central source of truth)","text":"<p>Instead of every machine maintaining its own mapping, John introduces a DNS server.</p> <p>Now:</p> <ul> <li>One system stores name → IP mappings</li> <li>All hosts query it</li> <li>Changes are made in one place</li> </ul> <p>This becomes the source of truth.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#etcresolvconf-where-linux-looks-for-dns","level":2,"title":"<code>/etc/resolv.conf</code> (where Linux looks for DNS)","text":"<p>Each Linux host must know which DNS server to ask.</p> <p>John checks:</p> <pre><code>cat /etc/resolv.conf\n</code></pre> <p>He adds:</p> <pre><code>nameserver 192.168.1.53\n</code></pre> <p>Now:</p> <ul> <li>Every hostname lookup goes to the DNS server</li> <li><code>/etc/hosts</code> is no longer the only source</li> </ul>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#local-override-still-exists","level":2,"title":"Local override still exists","text":"<p>Even with DNS configured, <code>/etc/hosts</code> still works.</p> <p>John can add temporary entries:</p> <pre><code>192.168.1.100 temp-db\n</code></pre> <p>No DNS change required.</p> <p>This is useful for:</p> <ul> <li>Testing</li> <li>Temporary servers</li> <li>Debugging</li> </ul>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#resolution-order-who-is-asked-first","level":2,"title":"Resolution order (who is asked first)","text":"<p>Linux follows an order when resolving names.</p> <p>That order is defined in:</p> <pre><code>/etc/nsswitch.conf\n</code></pre> <p>John checks the <code>hosts</code> line:</p> <pre><code>hosts: files dns\n</code></pre> <p>Meaning:</p> <ol> <li>Check <code>/etc/hosts</code></li> <li>If not found, query DNS</li> </ol> <p>This order can be changed, but the default is sensible.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#dns-for-the-internet","level":2,"title":"DNS for the internet","text":"<p>Internal DNS servers cannot resolve internet domains by themselves.</p> <p>To fix this, John configures DNS forwarding.</p> <p>The DNS server forwards unknown requests to public DNS servers like:</p> <pre><code>8.8.8.8\n8.8.4.4\n</code></pre> <p>Now:</p> <ul> <li>Internal names resolve internally</li> <li>External names resolve via the internet</li> </ul>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#domain-names-how-names-are-structured","level":2,"title":"Domain names (how names are structured)","text":"<p>DNS names are hierarchical.</p> <p>Example:</p> <pre><code>apps.google.com\n</code></pre> <p>Breakdown:</p> <ul> <li><code>.com</code> → top-level domain</li> <li><code>google</code> → domain</li> <li><code>apps</code> → subdomain</li> </ul> <p>Other top-level domains:</p> <ul> <li><code>.com</code> → commercial</li> <li><code>.net</code> → network</li> <li><code>.org</code> → organization</li> <li><code>.edu</code> → education</li> <li><code>.io</code> → Indian Ocean territory (popular in tech)</li> </ul>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#how-dns-resolution-actually-happens","level":2,"title":"How DNS resolution actually happens","text":"<p>When John accesses:</p> <pre><code>apps.google.com\n</code></pre> <p>Resolution flow:</p> <ol> <li>Organization DNS checks cache</li> <li>If not found, asks root DNS</li> <li>Root DNS points to <code>.com</code> DNS</li> <li><code>.com</code> DNS points to Google DNS</li> <li>Google DNS returns IP for <code>apps.google.com</code></li> </ol> <p>The result is cached so the next request is faster.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#search-domains-short-names-inside-organizations","level":2,"title":"Search domains (short names inside organizations)","text":"<p>Inside John’s company, the database server is named:</p> <pre><code>db.mycompany.com\n</code></pre> <p>John wants to type:</p> <pre><code>ping db\n</code></pre> <p>Linux supports this using search domains.</p> <p>In <code>/etc/resolv.conf</code>:</p> <pre><code>search mycompany.com\n</code></pre> <p>Now:</p> <ul> <li><code>db</code> automatically expands to <code>db.mycompany.com</code></li> <li>Multiple search domains can be configured</li> </ul>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#dns-record-types-what-dns-stores","level":2,"title":"DNS record types (what DNS stores)","text":"<p>DNS does not store just one type of record.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#a-record","level":3,"title":"A record","text":"<p>Maps hostname to IPv4 address.</p> <pre><code>db.mycompany.com → 192.168.1.1\n</code></pre>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#aaaa-record","level":3,"title":"AAAA record","text":"<p>Maps hostname to IPv6 address.</p> <pre><code>db.mycompany.com → fe80::1\n</code></pre>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#cname-record","level":3,"title":"CNAME record","text":"<p>Creates an alias.</p> <pre><code>web.mycompany.com → app.mycompany.com\n</code></pre> <p>Used when:</p> <ul> <li>One service has multiple names</li> <li>Backends change, names do not</li> </ul>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#testing-dns-resolution","level":2,"title":"Testing DNS resolution","text":"<p>John tests DNS directly.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#nslookup","level":3,"title":"<code>nslookup</code>","text":"<pre><code>nslookup db.mycompany.com\n</code></pre> <p>This queries DNS servers directly. It ignores <code>/etc/hosts</code>.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#dig","level":3,"title":"<code>dig</code>","text":"<pre><code>dig db.mycompany.com\n</code></pre> <p>This provides:</p> <ul> <li>Full DNS response</li> <li>Useful debugging details</li> </ul> <p>Preferred tool for troubleshooting.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#what-john-understands-now","level":2,"title":"What John understands now","text":"<ul> <li>IPs are hard to use directly</li> <li>Name resolution converts names to IPs</li> <li><code>/etc/hosts</code> is local and limited</li> <li>DNS is centralized and scalable</li> <li>Resolution order matters</li> <li>DNS caching improves performance</li> <li>Search domains simplify internal usage</li> </ul> <p>DNS works because everyone agrees on where truth lives.</p>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/dns/#quick-cheat-sheet","level":2,"title":"Quick cheat sheet","text":"<pre><code># Local name mapping\n/etc/hosts\n\n# DNS server config\n/etc/resolv.conf\n\n# Resolution order\n/etc/nsswitch.conf\n\n# Test DNS\nnslookup hostname\ndig hostname\n</code></pre>","path":["Devops","Networking","DNS Basics"],"tags":[]},{"location":"devops/networking/networking-basics/","level":1,"title":"Networking Basics","text":"","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#switching-routing-and-gateways-one-idea-at-a-time","level":2,"title":"Switching, routing, and gateways (one idea at a time)","text":"<p>John now has multiple Linux systems. They all work individually, but real systems are useless unless they can talk to each other.</p> <p>This page explains how communication works, step by step, without skipping logic.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#switch-how-two-systems-meet","level":2,"title":"Switch (how two systems meet)","text":"<p>Two systems talk to each other by being part of the same network.</p> <p>A switch creates that network.</p> <p>John connects: - System A - System B</p> <p>to the same switch.</p> <p>At this point, the switch only knows how to pass packets, not who is who.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#network-interface-how-a-system-connects","level":2,"title":"Network interface (how a system connects)","text":"<p>To connect to a switch, each system needs a network interface.</p> <p>John checks available interfaces:</p> <pre><code>ip link\n````\n\nHe sees:\n\n```text\neth0\n</code></pre> <p>This interface represents the physical or virtual connection to the switch.</p> <p>No interface means no network connectivity.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#ip-address-identity-on-the-network","level":2,"title":"IP address (identity on the network)","text":"<p>A switch alone is not enough. Each system needs an IP address.</p> <p>John chooses a network:</p> <pre><code>192.168.1.0/24\n</code></pre> <p>He assigns IPs.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#system-a","level":3,"title":"System A","text":"<pre><code>ip addr add 192.168.1.10/24 dev eth0\n</code></pre>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#system-b","level":3,"title":"System B","text":"<pre><code>ip addr add 192.168.1.11/24 dev eth0\n</code></pre> <p>Now:</p> <ul> <li>Both systems are on the same network</li> <li>Each has a unique identity</li> <li>They can talk to each other</li> </ul>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#route-how-linux-decides-where-to-send-packets","level":2,"title":"Route (how Linux decides where to send packets)","text":"<p>Linux does not guess. It uses a routing table.</p> <p>John checks it:</p> <pre><code>route\n</code></pre> <p>This shows the kernel IP routing table.</p> <p>Every outgoing packet is matched against this table to decide:</p> <ul> <li>Where to send it</li> <li>Through which interface</li> </ul> <p>If no route matches, the packet is dropped.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#router-how-networks-talk-to-networks","level":2,"title":"Router (how networks talk to networks)","text":"<p>Now John has two networks:</p> <pre><code>192.168.1.0/24\n192.168.2.0/24\n</code></pre> <p>A router connects networks.</p> <p>A router is simply a system that:</p> <ul> <li>Has an IP in each network</li> <li>Can forward packets between them</li> </ul> <p>Example router IPs:</p> <ul> <li>192.168.1.11</li> <li>192.168.2.11</li> </ul>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#gateway-how-systems-find-the-router","level":2,"title":"Gateway (how systems find the router)","text":"<p>The router is just another device. How does a system know it should use it?</p> <p>That device becomes the gateway.</p> <p>A gateway is:</p> <ul> <li>The next hop for another network</li> <li>The “door” out of the current network</li> </ul> <p>John adds a route:</p> <pre><code>ip route add 192.168.2.0/24 via 192.168.1.11\n</code></pre> <p>Meaning:</p> <p>“To reach 192.168.2.0, send packets to 192.168.1.11”</p> <p>This must be added on every system that needs access to the other network.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#default-gateway-door-to-everything-else","level":2,"title":"Default gateway (door to everything else)","text":"<p>The internet has too many networks to define routes for each.</p> <p>So systems use a default gateway.</p> <p>Default means:</p> <ul> <li>“If no route matches, send traffic here”</li> </ul> <p>John adds:</p> <pre><code>ip route add default via 192.168.1.11\n</code></pre> <p>Now:</p> <ul> <li>Known networks use specific routes</li> <li>All other traffic goes to the gateway</li> </ul> <p>This is how systems reach the internet.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#linux-as-a-router-packet-forwarding","level":2,"title":"Linux as a router (packet forwarding)","text":"<p>John now wants his Linux system to act as a router.</p> <p>By default, Linux does not forward packets between interfaces.</p> <p>He checks:</p> <pre><code>cat /proc/sys/net/ipv4/ip_forward\n</code></pre> <p>Output:</p> <pre><code>0\n</code></pre> <p>This means forwarding is disabled.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#enabling-forwarding-making-linux-a-router","level":2,"title":"Enabling forwarding (making Linux a router)","text":"<p>John enables forwarding temporarily:</p> <pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward\n</code></pre> <p>To make it permanent, he updates:</p> <pre><code>/etc/sysctl.conf\n</code></pre> <p>Adds:</p> <pre><code>net.ipv4.ip_forward = 1\n</code></pre> <p>Applies it:</p> <pre><code>sysctl -p\n</code></pre> <p>Now Linux forwards packets between networks.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#what-john-understands-now","level":2,"title":"What John understands now","text":"<ul> <li>Switch connects systems in the same network</li> <li>Interfaces connect systems to the switch</li> <li>IP addresses identify systems</li> <li>Routes decide where packets go</li> <li>Gateways point to routers</li> <li>Default gateway handles unknown networks</li> <li>Linux can be a router, but only if forwarding is enabled</li> </ul> <p>Networking works because everything is explicit.</p>","path":["Devops","Networking","Networking Basics"],"tags":[]},{"location":"devops/networking/networking-basics/#quick-cheat-sheet","level":2,"title":"Quick cheat sheet","text":"<pre><code># Show interfaces\nip link\n\n# Assign IP\nip addr add &lt;ip&gt;/&lt;mask&gt; dev &lt;iface&gt;\n\n# Show routes\nroute\n\n# Add route\nip route add &lt;network&gt; via &lt;gateway&gt;\n\n# Add default gateway\nip route add default via &lt;gateway&gt;\n\n# Enable forwarding\necho 1 &gt; /proc/sys/net/ipv4/ip_forward\n</code></pre>","path":["Devops","Networking","Networking Basics"],"tags":[]}]}